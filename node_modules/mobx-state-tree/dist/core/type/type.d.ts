import { IValidationContext, IValidationResult, IStateTreeNode, ModelPrimitive } from "../../internal";
/**
 * Name of the properties of an object that can't be set to undefined
 * @hidden
 */
export declare type DefinablePropsNames<T> = {
    [K in keyof T]: Extract<T[K], undefined> extends never ? K : never;
}[keyof T];
/**
 * Checks if a type is any or unknown
 * @hidden
 */
export declare type IsTypeAnyOrUnknown<T> = unknown extends T ? true : false;
declare type WithoutUndefined<T> = T extends undefined ? never : T;
/**
 * Checks if a type is optional (its creation snapshot can be undefined) or not.
 * @hidden
 *
 * Examples:
 * - string = false
 * - undefined = true
 * - string | undefined = true
 * - string & undefined = true
 * - any = true
 * - unknown = true
 */
export declare type IsOptionalType<IT extends IAnyType> = ExtractC<IT> extends WithoutUndefined<ExtractC<IT>> ? IsTypeAnyOrUnknown<ExtractC<IT>> : true;
/**
 * Checks if a type supports an empty create() function
 * Basically !any, !unknown, X | undefined, objects with all properties being optional
 * @hidden
 */
export declare type IsEmptyCreationType<O> = IsTypeAnyOrUnknown<O> extends true ? true : Extract<O, undefined> extends never ? (DefinablePropsNames<O> extends never | undefined ? true : false) : true;
/**
 * Chooses a create function based on the creation type.
 * @hidden
 */
export declare type CreateParams<C> = IsEmptyCreationType<C> extends false ? [C, any?] : [C?, any?];
/**
 * @hidden
 */
export declare type STNValue<T, IT extends IAnyType> = Extract<T, object> extends never ? T : (Extract<T, object> & IStateTreeNode<IT>) | Exclude<T, object>;
/**
 * A type, either complex or simple.
 */
export interface IType<C, S, T> {
    /**
     * Friendly type name.
     */
    name: string;
    /**
     * Name of the dentifier attribute or null if none.
     */
    readonly identifierAttribute?: string;
    create(...args: CreateParams<C>): STNValue<T, this>;
    /**
     * Creates an instance for the type given an snapshot input.
     *
     * @returns An instance of that type.
     */
    create(snapshot: C, env?: any): STNValue<T, this>;
    /**
     * Checks if a given snapshot / instance is of the given type.
     *
     * @param thing Snapshot or instance to be checked.
     * @returns true if the value is of the current type, false otherwise.
     */
    is(thing: any): thing is C | STNValue<T, this>;
    /**
     * Run's the type's typechecker on the given value with the given validation context.
     *
     * @param thing Value to be checked, either a snapshot or an instance.
     * @param context Validation context, an array of { subpaths, subtypes } that should be validated
     * @returns The validation result, an array with the list of validation errors.
     */
    validate(thing: C, context: IValidationContext): IValidationResult;
    /**
     * Gets the textual representation of the type as a string.
     */
    describe(): string;
    /**
     * @deprecated use `Instance<typeof MyType>` instead.
     * @hidden
     */
    readonly Type: STNValue<T, this>;
    /**
     * @deprecated use `SnapshotOut<typeof MyType>` instead.
     * @hidden
     */
    readonly SnapshotType: S;
    /**
     * @deprecated use `SnapshotIn<typeof MyType>` instead.
     * @hidden
     */
    readonly CreationType: C;
}
/**
 * Any kind of type.
 */
export declare type IAnyType = IType<any, any, any>;
/**
 * A simple type, this is, a type where the instance and the snapshot representation are the same.
 */
export interface ISimpleType<T> extends IType<T, T, T> {
}
/** @hidden */
export declare type Primitives = ModelPrimitive | null | undefined;
/**
 * A complex type.
 * @deprecated just for compatibility with old versions, could be deprecated on the next major version
 * @hidden
 */
export interface IComplexType<C, S, T> extends IType<C, S, T & object> {
}
/**
 * Any kind of complex type.
 */
export declare type IAnyComplexType = IType<any, any, object>;
/** @hidden */
export declare type ExtractC<T extends IAnyType> = T extends IType<infer C, any, any> ? C : never;
/** @hidden */
export declare type ExtractS<T extends IAnyType> = T extends IType<any, infer S, any> ? S : never;
/** @hidden */
export declare type ExtractTWithoutSTN<T extends IAnyType> = T extends IType<any, any, infer X> ? X : never;
/** @hidden */
export declare type ExtractTWithSTN<T extends IAnyType> = InstanceWithDefault<T, never>;
/** @hidden */
export declare type ExtractCSTWithoutSTN<IT extends IAnyType> = IT extends IType<infer C, infer S, infer T> ? C | S | T : never;
/** @hidden */
export declare type ExtractCSTWithSTN<IT extends IAnyType> = IT extends IType<infer C, infer S, infer T> ? C | S | ExtractTWithSTN<IT> : never;
declare type InstanceWithDefault<T, DEFAULT> = T extends IType<any, any, infer TT> ? STNValue<TT, T> : DEFAULT;
/**
 * The instance representation of a given type.
 */
export declare type Instance<T> = InstanceWithDefault<T, T>;
/**
 * The input (creation) snapshot representation of a given type.
 */
export declare type SnapshotIn<T> = T extends IStateTreeNode<IType<infer STNC, any, any>> ? STNC : T extends IType<infer TC, any, any> ? TC : T;
/**
 * The output snapshot representation of a given type.
 */
export declare type SnapshotOut<T> = T extends IStateTreeNode<IType<any, infer STNS, any>> ? STNS : T extends IType<any, infer TS, any> ? TS : T;
/**
 * A type which is equivalent to the union of SnapshotIn and Instance types of a given typeof TYPE or typeof VARIABLE.
 * For primitives it defaults to the primitive itself.
 *
 * For example:
 * - `SnapshotOrInstance<typeof ModelA> = SnapshotIn<typeof ModelA> | Instance<typeof ModelA>`
 * - `SnapshotOrInstance<typeof self.a (where self.a is a ModelA)> = SnapshotIn<typeof ModelA> | Instance<typeof ModelA>`
 *
 * Usually you might want to use this when your model has a setter action that sets a property.
 *
 * Example:
 * ```ts
 * const ModelA = types.model({
 *   n: types.number
 * })
 *
 * const ModelB = types.model({
 *   innerModel: ModelA
 * }).actions(self => ({
 *   // this will accept as property both the snapshot and the instance, whichever is preferred
 *   setInnerModel(m: SnapshotOrInstance<typeof self.innerModel>) {
 *     self.innerModel = cast(m)
 *   }
 * }))
 * ```
 */
export declare type SnapshotOrInstance<T> = SnapshotIn<T> | Instance<T>;
/**
 * Returns if a given value represents a type.
 *
 * @param value Value to check.
 * @returns `true` if the value is a type.
 */
export declare function isType(value: any): value is IAnyType;
export {};
